<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>PhysicsJS test</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width">

  <!-- General styles -->
  <link rel="stylesheet" href="style.css">
  <!-- Page styles -->
  <style>

  
  </style>

</head>
<body>

<!-- Setup -->
    <button class="start-stop">Pause</button>
    <canvas id="viewport"></canvas>

<!-- Scripts -->
<script src="../dist/physicsjs-0.0.1a.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>

Physics({

    // config
    timestep: 1000 / 160 

}, function( world ){

    var viewWidth = 600;
    var viewHeight = 400;
    var viewportBounds = Physics.bounds(0, 0, viewWidth, viewHeight);

    var circles = [];
    
    for ( var i = 0, l = 60; i < l; ++i )
    circles.push(
        Physics.body('circle', {
            x: 10 * i % 380 + 10,
            y: Math.floor(10 * i / 380)* 10 + 10,
            vx: 0,
            radius: 5,
            restitution: 0.99,
            angularVelocity: 0
        })
    );

    // circles.push(
    //     Physics.body('circle', {
    //         x: 300,
    //         y: 200,
    //         radius: 10,
    //         vx: -0.02,
    //         vy: 0,
    //         angularVelocity: 0
    //     })
    // );

    // circles.push(
    //     Physics.body('circle', {
    //         x: 300,
    //         y: 300,
    //         radius: 12,
    //         mass: 1.5,
    //         vx: 0.01,
    //         vy: 0
    //     })
    // );

    var renderer = Physics.renderer('canvas', {
        el: 'viewport',
        width: viewWidth,
        height: viewHeight
    });

    // add things to world
    // world.add( constrain );
    world.add( circles );
    world.add( renderer );
    world.add( Physics.integrator('verlet', { drag: 0 }));
    world.add( Physics.behavior('gravity', function(){

        var g = Physics.vector(0, .0004)
            ,mouse = Physics.vector()
            ,mouseDown = false
            ,tmp = Physics.vector()
            ;

        $('#viewport').on({
            mousedown: function(e){
                mouseDown = true;
            },
            mousemove: function(e){
                var offset = $(this).offset();
                mouse.set(e.screenX - offset.left, e.screenY - offset.top);
            },
            mouseup: function(e){
                mouseDown = false;
            }
        });

        return {
            behave: function( bodies ){

                for ( var i = 0, l = bodies.length; i < l; ++i ){
                    
                    bodies[ i ].accelerate( g );

                    if (mouseDown){
                        tmp.clone(mouse).vsub(bodies[ i ].state.pos).normalize().mult(0.001);
                        bodies[ i ].accelerate( tmp );
                    }
                }
            }
        };
    }, {}) );

    world.add(Physics.behavior('simple-collision-detection', function( parent ){

        var PUBSUB_TOPIC = 'collision-detect';

        var detectCircleCollisions = function detectCircleCollisions( bodies, dt, callback ){

            var bodyA
                ,bodyB
                ,scratch = Physics.scratchpad()
                ,d = scratch.vector()
                ,tmp = scratch.vector()
                ,overlap
                ;

            if (!callback) return;

            for ( var j = 0, l = bodies.length; j < l; j++ ){
                
                bodyA = bodies[ j ];

                for ( var i = j + 1; i < l; i++ ){

                    bodyB = bodies[ i ];

                    d.clone( bodyB.state.pos ).vsub( bodyA.state.pos );
                    overlap = d.norm() - (bodyA.geometry.radius + bodyB.geometry.radius);

                    if ( overlap > 0 ){
                        // check the future
                        d.vadd( tmp.clone(bodyB.state.vel).mult( dt ) ).vsub( tmp.clone(bodyA.state.vel).mult( dt ) );
                        overlap = d.norm() - (bodyA.geometry.radius + bodyB.geometry.radius);
                    }

                    if ( overlap <= 0 ){

                        callback({
                            topic: PUBSUB_TOPIC,
                            bodyA: bodyA,
                            bodyB: bodyB,
                            norm: d.normalize().values(),
                            pos: d.mult( bodyA.geometry.radius ).vadd( bodyA.state.pos ).values(),
                            mtv: d.vsub( bodyA.state.pos ).normalize().mult( overlap ).values(),
                            overlap: overlap
                        });
                    }
                }
            }

            scratch.done();
        };

        var sweep = function sweep( data ){
            if (!data.callback || !this._world){
                return;
            }
            
            var list = [];
            detectCircleCollisions( this._world._bodies, this._world.timeStep(), function( data ){
                list.push( data );
            });
            data.callback( list );
        }

        return {

            priority: 10,

            init: function( options ){

                parent.init.call(this, options);

                this.sweep = Physics.util.bind(this.sweep, this);
            },

            setWorld: function( world ){

                if (this._world){

                    this._world.unsubscribe( PUBSUB_TOPIC + ':request-sweep', this.sweep );
                }

                world.subscribe( PUBSUB_TOPIC + ':request-sweep', this.sweep );

                parent.setWorld.call( this, world );
            },

            sweep: sweep,

            behave: function( bodies, dt ){
                var world = this._world;
                detectCircleCollisions( bodies, dt, function( data ){
                    world.publish( data );
                });
            }
        };

    }, {}));

    window.runningMaxOverlap = 0;
    world.subscribe( 'collision-detect', function(data){

        window.runningMaxOverlap = Math.min(window.runningMaxOverlap, data.overlap);
    });
    
    // world.add( Physics.behavior('newtonian', { strength: .02 }) );
    world.add( Physics.behavior('body-impulse-response') );
    world.add( Physics.behavior('edge-bounce', { bounds: viewportBounds, restitution: 0.8 }) );

    Physics.util.ticker.subscribe(function( time, dt ){

        world.step( time );
        world.render();
    });

    Physics.util.ticker.start();

    // play/pause button
    $(document).on('click', '.start-stop', function(e){

        e.preventDefault();
        var paused = world.isPaused();

        if (paused){
            $(this).text('pause');
            world.unpause();
        } else {
            $(this).text('play');
            world.pause();
        }
    });
});

</script>
  
</body>
</html>