<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>PhysicsJS test</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width">

  <!-- General styles -->
  <link rel="stylesheet" href="style.css">
  <!-- Page styles -->
  <style>

  
  </style>

</head>
<body>

<!-- Setup -->
    <button class="start-stop">Pause</button>
    <button class="next">Next Frame</button>
    <canvas id="viewport"></canvas>

<!-- Scripts -->
<script src="../dist/physicsjs-0.0.1a.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>

Physics({

    // config
    timestep: 1000 / 160 

}, function( world ){

    var viewWidth = 600;
    var viewHeight = 400;
    var viewportBounds = Physics.aabb(0, 0, viewWidth, viewHeight);
    var pent = [
            { x: 60, y: 0 },
            { x: 30, y: -30 },
            { x: -30, y: -30 },
            { x: -60, y: 0 },
            { x: 0, y: 60 }
        ];

    var circles = [];
    
    for ( var i = 0, l = 10; i < l; ++i )
    circles.push(
        Physics.body('circle', {
            x: 30 * i % 380 + 10,
            y: Math.floor(10 * i / 380)* 10 + 100,
            vx: 0.05,
            radius: 10,
            restitution: 0.7,
            angularVelocity: 0
        })
    );

    circles.push(
        Physics.body('circle', {
            x: 10,
            y: 280,
            vx: 0.05,
            radius: 10,
            restitution: 0.99,
            // cof: 0.00000000000001,
            angularVelocity: 0
        })
    );
    
    // polly the polygon
    for ( var i = 0, l = 10; i < l; ++i ){
        
        poly = Physics.body('convex-polygon', {
            // vertices: pent,
            vertices: [
                {x: 0, y: 20},
                {x: 20, y: 20},
                {x: 20, y: 0},
                {x: 0, y: 0}
            ],
            x: 40*(i/6|0)+200,
            y: 21*(i%6)+200,
            vx: 0,
            // cof: 0.7,
            restitution: 0.7,
            fixed: false
        });

        world.add( poly );
    }

    
    var renderer = Physics.renderer('canvas', {
        el: 'viewport',
        width: viewWidth,
        height: viewHeight
    });

    // add things to world
    // world.add( constrain );
    world.add( circles );
    world.add( Physics.body('convex-polygon', {
        vertices: [
            { x: 0, y: 0 },
            { x: viewWidth, y: 0 },
            { x: viewWidth, y: -40 },
            { x: 0, y: -40 }
        ],
        x: viewWidth / 2,
        y: viewHeight - 10,
        restitution: 0.7,
        fixed: true
    }));

    world.add( renderer );
    world.add( Physics.integrator('verlet', { drag: 0 }));
    world.add( Physics.behavior('gravity', function(){

        var g = Physics.vector(0, .0004)
            ,mouse = Physics.vector()
            ,mouseDown = false
            ,tmp = Physics.vector()
            ;

        $('#viewport').on({
            mousedown: function(e){
                mouseDown = true;
            },
            mousemove: function(e){
                var offset = $(this).offset();
                mouse.set(e.screenX - offset.left, e.screenY - offset.top);
            },
            mouseup: function(e){
                mouseDown = false;
            }
        });

        return {
            behave: function( bodies ){

                for ( var i = 0, l = bodies.length; i < l; ++i ){
                    
                    bodies[ i ].accelerate( g );

                    if (mouseDown){
                        tmp.clone(mouse).vsub(bodies[ i ].state.pos).normalize().mult(0.001);
                        bodies[ i ].accelerate( tmp );
                    }
                }
            }
        };
    }, {}) );

    world.add(Physics.behavior('simple-collision-detection', function( parent ){

        var PUBSUB_TOPIC = 'collision-detect';

        // get general support function
        function getSupportFn( bodyA, bodyB ){

            var tA = Physics.transform( bodyA.state.pos, bodyA.state.angular.pos )
                ,tB = Physics.transform( bodyB.state.pos, bodyB.state.angular.pos )
                ,fn
                ;

            fn = function( searchDir ){

                var scratch = Physics.scratchpad()
                    ,vA = scratch.vector()
                    ,vB = scratch.vector()
                    ,method = fn.useCore? 'getFarthestCorePoint' : 'getFarthestHullPoint'
                    ,margin = fn.margin
                    ,ret
                    ;

                vA = bodyA.geometry[ method ]( searchDir.rotateInv( tA ), vA, margin ).transform( tA );
                vB = bodyB.geometry[ method ]( searchDir.rotate( tA ).rotateInv( tB ).negate(), vB, margin ).transform( tB );

                searchDir.negate().rotate( tB );

                ret = {
                    a: vA.values(),
                    b: vB.values(),
                    pt: vA.vsub( vB ).values() 
                };
                scratch.done();
                return ret;
            };

            fn.useCore = false;
            fn.margin = 0;

            return fn;
        }

        var detectCollisions = function detectCollisions( bodies, dt, callback ){

            var bodyA
                ,bodyB
                ,scratch = Physics.scratchpad()
                ,d = scratch.vector()
                ,tmp = scratch.vector()
                ,overlap
                ,result
                ,support
                ,collision
                ;

            if (!callback) {
                scratch.done();
                return;
            }

            for ( var j = 0, l = bodies.length; j < l; j++ ){
                
                bodyA = bodies[ j ];

                for ( var i = j + 1; i < l; i++ ){

                    bodyB = bodies[ i ];

                    if ( bodyA.fixed && bodyB.fixed ){
                        // don't detect two fixed bodies
                        continue;
                    }

                    // just check the overlap first
                    support = getSupportFn( bodyA, bodyB );
                    d.clone( bodyA.state.pos ).vsub( bodyB.state.pos );
                    result = Physics.gjk(support, d, true);

                    if ( result.overlap ){

                        // there is a collision. let's do more work.
                        collision = {
                            topic: PUBSUB_TOPIC,
                            bodyA: bodyA,
                            bodyB: bodyB
                        };

                        // first get the min distance of between core objects
                        support.useCore = true;
                        support.margin = 0;

                        while ( result.overlap ){
                            support.margin += 2;
                            result = Physics.gjk(support, d);
                        }
                        
                        if ( result.overlap || result.maxIterationsReached ){
                            scratch.done();
                            console.log(result);
                            // This implementation can't deal with a core overlap yet
                            throw "oops overlap";
                        }

                        // calc overlap
                        overlap = Math.max(0, 2 * support.margin - result.distance);
                        collision.overlap = overlap;
                        // @TODO: for now, just let the normal be the mtv
                        collision.norm = d.clone( result.closest.b ).vsub( tmp.clone( result.closest.a ) ).normalize().values();
                        collision.mtv = d.mult( overlap ).values();
                        // get a corresponding hull point for one of the core points
                        // collision.pos = d.clone( result.closest.b ).vsub( bodyB.state.pos );
                        // overlap = collision.pos.norm();
                        // collision.pos = collision.pos.mult( 1 + support.margin / overlap ).vadd( bodyB.state.pos ).values();
                        collision.pos = d.clone( collision.norm ).mult( support.margin ).vadd( tmp.clone( result.closest.a ) ).values();
                        // world.render();
                        // renderer.drawCircle(collision.pos.x, collision.pos.y, 1, 'green')
                        // renderer.drawCircle(result.closest.a.x, result.closest.a.y, 1, 'blue')
                        // renderer.drawCircle(result.closest.b.x, result.closest.b.y, 1, 'red')
                        
                        // send it to the callback
                        callback( collision );
                    }
                }
            }

            scratch.done();
        };

        var detectCircleCollisions = function detectCircleCollisions( bodies, dt, callback ){

            var bodyA
                ,bodyB
                ,scratch = Physics.scratchpad()
                ,d = scratch.vector()
                ,tmp = scratch.vector()
                ,overlap
                ;

            if (!callback) {
                scratch.done();
                return;
            }

            for ( var j = 0, l = bodies.length; j < l; j++ ){
                
                bodyA = bodies[ j ];

                for ( var i = j + 1; i < l; i++ ){

                    bodyB = bodies[ i ];

                    d.clone( bodyB.state.pos ).vsub( bodyA.state.pos );
                    overlap = d.norm() - (bodyA.geometry.radius + bodyB.geometry.radius);

                    if ( overlap > 0 ){
                        // check the future
                        d.vadd( tmp.clone(bodyB.state.vel).mult( dt ) ).vsub( tmp.clone(bodyA.state.vel).mult( dt ) );
                        overlap = d.norm() - (bodyA.geometry.radius + bodyB.geometry.radius);
                    }

                    if ( overlap <= 0 ){

                        callback({
                            topic: PUBSUB_TOPIC,
                            bodyA: bodyA,
                            bodyB: bodyB,
                            norm: d.normalize().values(),
                            pos: d.mult( bodyA.geometry.radius ).vadd( bodyA.state.pos ).values(),
                            mtv: d.vsub( bodyA.state.pos ).normalize().mult( overlap ).negate().values(),
                            overlap: overlap
                        });
                    }
                }
            }

            scratch.done();
        };

        var sweep = function sweep( data ){
            if (!data.callback || !this._world){
                return;
            }
            
            var list = [];
            detectCollisions( this._world._bodies, this._world.timeStep(), function( data ){
                list.push( data );
            });
            data.callback( list );
        }

        return {

            priority: 10,

            init: function( options ){

                parent.init.call(this, options);

                this.sweep = Physics.util.bind(this.sweep, this);
            },

            setWorld: function( world ){

                if (this._world){

                    this._world.unsubscribe( PUBSUB_TOPIC + ':request-sweep', this.sweep );
                }

                world.subscribe( PUBSUB_TOPIC + ':request-sweep', this.sweep );

                parent.setWorld.call( this, world );
            },

            sweep: sweep,

            behave: function( bodies, dt ){
                var world = this._world;
                detectCollisions( bodies, dt, function( data ){
                    world.publish( data );
                });
            }
        };

    }, {}));

    window.runningMaxOverlap = 0;
    world.subscribe( 'collision-detect', function(data){
        // console.log( data )
        window.runningMaxOverlap = Math.min(window.runningMaxOverlap, data.overlap);
    });
    
    // world.add( Physics.behavior('newtonian', { strength: .02 }) );
    world.add( Physics.behavior('body-impulse-response') );
    world.add( Physics.behavior('edge-bounce', { aabb: viewportBounds, restitution: 0.8 }) );

    Physics.util.ticker.subscribe(function( time, dt ){

        world.step( time );
        world.render();
    });

    Physics.util.ticker.start();

    // play/pause button
    $(document).on('click', '.start-stop', function(e){

        e.preventDefault();
        var paused = world.isPaused();

        if (paused){
            $(this).text('pause');
            world.unpause();
        } else {
            $(this).text('play');
            world.pause();
        }
    });

    $(document).on('click', '.next', function(e){

        world.unpause();
        world.step( 1 ).step( 21 );
        world.pause();
    });
});

</script>
  
</body>
</html>