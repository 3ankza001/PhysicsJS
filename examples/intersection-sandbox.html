<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>PhysicsJS test</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width">

  <!-- General styles -->
  <link rel="stylesheet" href="style.css">
  <!-- Page styles -->
  <style>

  
  </style>

</head>
<body>

<!-- Setup -->
    <canvas id="viewport"></canvas>

<!-- Scripts -->
<script src="../dist/physicsjs-0.0.1a.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>

// helpers

function drawPoint(ctx, p, radius, color) {
    ctx.beginPath();
    ctx.arc(p.get(0), p.get(1), radius, 0, Math.PI*2, false);     

    ctx.fillStyle = color;
    ctx.fill();
}

function drawSimplex(ctx, simplex, lineWidth, strokeColor, offset) {
    if (!simplex || !simplex.length) return;
    ctx.save();
    ctx.translate(offset.get(0), offset.get(1));
    ctx.beginPath();

    ctx.moveTo(simplex[0].pt.x, simplex[0].pt.y);     
    for (var i = 1; i < simplex.length; i++) {
        ctx.lineTo(simplex[i].pt.x, simplex[i].pt.y);
    }

    // if (v.length > 2) {
    //     ctx.closePath();
    // }

    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = strokeColor;
    ctx.stroke();
    ctx.restore();
}

// main
Physics({

    // config
    timestep: 1000 / 160 

}, function( world ){

    var viewWidth = 600;
    var viewHeight = 400;
    var viewportBounds = Physics.bounds(0, 0, viewWidth, viewHeight);

    var circles = [];
    
    circles.push(
        Physics.body('circle', {
            x: 200,
            y: 0,
            radius: 35
        })
    );

    circles.push(
        Physics.body('circle', {
            x: 200,
            y: 100,
            radius: 30,
            mass: 2,
            angularVelocity: 0.01
        })
    );

    var renderer = Physics.renderer('canvas', {
        el: 'viewport',
        width: viewWidth,
        height: viewHeight,
        offset: Physics.vector( viewWidth/2, viewHeight/2 )
    });

    // add things to world
    // world.add( constrain );
    world.add( circles );
    world.add( renderer );

    function updateCanvas( simplex ){
        var ctx = renderer.ctx;
        renderer.render(world._bodies, { fps: 0, steps: 0 });
        // draw origin
        drawPoint(ctx, renderer.options.offset, 2, 'red');
        drawMinkowski( ctx, circles[0], circles[1] );
        drawSimplex(ctx, simplex, 1, '#448', renderer.options.offset);
    }

    var toTitleCase = function toTitleCase(str) {
       return str.replace(/(?:^|\s)\w/g, function(match) {
            return match.toUpperCase();
        });
    };

    function drawMinkowski(ctx, bodyA, bodyB){
        var support = getSupportFn( bodyA, bodyB )
            ,dir = Physics.vector(1, 0)
            ,transform = Physics.transform()
            ,point = Physics.vector()
            ;

        for ( var i = 0, l = 2*Math.PI; i < l; i += 0.1 ){
            
            transform.setRotation( i );
            dir.rotate(transform);
            point.clone( support( dir ).pt );
            drawPoint(ctx, point.vadd(renderer.options.offset), 0.5, '#ddd');
        }

    }

    // general support function
    function getSupportFn( bodyA, bodyB, useCore ){

        var tA = Physics.transform( bodyA.state.pos, bodyA.state.angular.pos )
            ,tB = Physics.transform( bodyB.state.pos, bodyB.state.angular.pos )
            ,fn = useCore? 'getFarthestCorePoint' : 'getFarthestHullPoint'
            ;

        return function( searchDir ){

            var scratch = Physics.scratchpad()
                ,vA = scratch.vector()
                ,vB = scratch.vector()
                ,ret
                ;

            vA = bodyA.geometry[ fn ]( searchDir.rotateInv( tA ), vA ).transform( tA );
            vB = bodyB.geometry[ fn ]( searchDir.rotate( tA ).rotateInv( tB ).negate(), vB ).transform( tB );

            searchDir.negate().rotate( tB );

            ret = {
                a: vA.values(),
                b: vB.values(),
                pt: vA.vsub( vB ).values() 
            };
            scratch.done();
            return ret;
        }
    }

    $('#viewport').on({
        mousedown: function(e){

            var body
                ,offset = $('#viewport').offset()
                ,diff = Physics.vector(e.pageX - offset.left, e.pageY - offset.top)
                ,pos = Physics.vector()
                ,bounds = Physics.bounds()
                ;

            diff.vsub( renderer.options.offset );

            for ( var i = 0, l = world._bodies.length; i < l; ++i ){

                body = world._bodies[ i ];

                pos.clone( body.state.pos ).sub( body.geometry.radius );
                bounds.set( pos.get(0), pos.get(1), pos.add( body.geometry.radius * 2).get(0), pos.get(1) );
                
                if (bounds.contains( diff )){

                    body = world._bodies[ i ];
                    break;
                }

                body = null;
            }

            diff.vadd( renderer.options.offset );

            if (body){

                diff.vsub(body.state.pos);

                $(window).on({
                    'mousemove.drag': function(e){

                        var bodyA
                            ,bodyB
                            ,method
                            ,ret
                            ;

                        bodyA = world._bodies[ 0 ];
                        bodyB = world._bodies[ 1 ];

                        pos.clone( bodyA.state.pos ).vsub( body.state.pos );

                        ret = Physics.gjk(getSupportFn( bodyA, bodyB ), pos);
                        
                        if (ret.overlap){

                            console.log('intersection', ret, 'iterations: '+ret.iterations);
                            $('body').css('background', '#833');
                        } else {

                            console.log('distance', ret.distance, 'iterations: ' + ret.iterations);
                            $('body').css('background', '#333');
                        }
                        

                        pos.set(e.pageX - offset.left, e.pageY - offset.top).vsub( diff );
                        body.state.pos.clone(pos);
                        updateCanvas( ret.simplex );
                    },
                    mouseup: function(e){
                        $(window).off('mousemove.drag');
                    }
                });
            }
        }
    });
    
    updateCanvas();
    setTimeout(function(){
        updateCanvas();
    }, 500);
});

</script>
  
</body>
</html>